
### RSA3

![RSA3](https://github.com/Hed6eH0g/ctf/blob/main/2023/byuctf/crypto/rsa3/figs/rsa3_0.png)

In this challenge, we have different ciphertexts `c1, c2` which were encrypted by the same public key `e1` under distinct moduli `n1, n2`. 
Since each modulus is composed of two prime numbers, we can try to check whether a prime is reused or not using gcd.

Fortunately, because there exists a common divisor of `n1,n2`, we can obtain every prime number consisting of the moduli, and the flag was recovered as well as RSA1 and RSA2.

```
n1 = 26936730986023789726214222876998431579035871765812234385674097050592112272540329063679602773116293498245937781951160051718036177035087801218359133356523071700951108999020905116034905584806261203518345118128714311038590925635180342040347317022008233631809623824589107373210514331169745651687793393307158179191306187356408951648269495142386375021669218752561961647301029204701333026044435685936341126368602940601101599988477874713569476970068734357580527463645209944448988010693985476127837819331701523891965427561798033127731232916390511986369304971158889254173850566560028528340860519614489276904182246324437302697433        

e1 = 65537

c1 = 25934221721388531303090294836956821212346696995428676440185777623629033147440636130540319272854260855117016879903925227836710795492438220977864741830686432435183222727791461378988782191893620213711460265022633971293289987925875691438890670054518553696690583070284033592035281829227897938832962322172505881421894428362134145126751766514249801481330619906708370005958557827981820321861133293595400304305721764486699677941331024345924352161482159664366018182446127343098427579677894070842066840562853624060861183697917208697602208453017595582242281467105778066369782229287834403074433848470534633158573935584429007575715        


n2 = 20923351960149847207730448386993771286287991808293298691185156471519720793292179321382926775933281826329369963004005667653815105072159583791658532166606431385861980687037872135521884790087813454844716254644626942821490878728677736261700329782075809716063515721266692286574071240561529911159730824490258866613280873755548760004314650585913096197607936750263556276920577987540676841745347308103070523989154846358123142014592046611945781700690640990848003152423310523158983857208127158850925297742214928064334410930947749935069628731105093722212442331657106356911123912454871778728334875010902513275561639806401894881233        

e2 = 65537

c2 = 599377359700746593451522370555094750039121373766206564497197778344656489082805044374716270406804818833159702992918228183744567458330193603796378891295436618092133751825113903290460378677477200991330560905371834736586417724754919264990820724019760239701000667748565850695528363819965169299043600654454978543425596509871536328726747025231812815835749059252179719939399366644663048724011101287811844340320520544010179529188112211115440469084617438296961494801221969674213288489675624156545941630517075958425681203711654677553772595530799489102830165490202523397154229276688719481530893488434863906070343


import math
from Crypto.Util.number import long_to_bytes

p = math.gcd(n1, n2)

if n1%p == 0:
  q1 = n1//p

if n2%p == 0:
  q2 = n2//p


phi1 = (p-1)*(q1-1)
phi2 = (p-1)*(q2-1)

d1 = pow(e1, -1, phi1)
d2 = pow(e2, -1, phi2)

m1 = pow(c1, d1, n1)
m2 = pow(c2, d2, n2)

print(long_to_bytes(m1))
print(long_to_bytes(m2))
```
